/*
  A kernel module to search for a process by name.
  After inserting this module, it will add a system call that takes a process name as input and returns a pid.
  In the terminal, compile this module with "make" and load it with "sudo insmod process_scanner.ko". 
  Unload it with "sudo rmmod process_scanner.ko".
*/

#include <linux/string.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/sched.h> // task_struct definition
#include <asm/unistd.h>
#include <linux/list.h>
#include <linux/init_task.h>
#include <linux/syscalls.h>
#include <linux/kallsyms.h>

#ifndef __KERNEL__
#define __KERNEL__
#endif


#define SYS_CALL_TABLE "sys_call_table"
#define SYSCALL_NI 400

static ulong *syscall_table = NULL;

static void *original_syscall = NULL;

static char buffer[40];

/* 
 * This function is inserted into the system call table as system call 400.
 * It takes a process name as input and returns the pid number if the process is found
 * or 0 if it is not found.
 */
static unsigned long get_task_by_name(const char *string) {

  // Read the input from the user
  if (copy_from_user(buffer, string, 40)) {
    return -EFAULT;
  }

  // The struct used for info of a process
  struct task_struct* task;

  // Go over through the list of processes
  for_each_process(task) {

    // Check if the process name matches
    if (strcmp(task->comm,buffer) == 0) {
        // Print to syslog
        printk("Malware found: %s, PID: %d\n", task->comm, task->pid);
        return (ulong)task->pid;
    }
  }

  return 0;
}

static int is_syscall_table(ulong *p)
{
        return ((p != NULL) && (p[__NR_close] == (ulong)sys_close));
}

static int page_read_write(ulong address)
{
        uint level;
        pte_t *pte = lookup_address(address, &level);

        if(pte->pte &~ _PAGE_RW)
                pte->pte |= _PAGE_RW;
        return 0;
}

static int page_read_only(ulong address)
{
        uint level;
        pte_t *pte = lookup_address(address, &level);
        pte->pte = pte->pte &~ _PAGE_RW;
        return 0;
}

/*
 * Replaces the system call at a specified offset.
 * 'offset' is the offset of the system call to replace and func_address is the function of the new
 * system call.
 */
static void replace_syscall(ulong offset, ulong func_address)
{

        syscall_table = (ulong *)kallsyms_lookup_name(SYS_CALL_TABLE);
        if (is_syscall_table(syscall_table)) {

                printk(KERN_INFO "Syscall table address : %p\n", syscall_table);
                page_read_write((ulong)syscall_table);
                original_syscall = (void *)(syscall_table[offset]);
                printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, original_syscall);
                printk(KERN_INFO "Custom syscall address %p\n", get_task_by_name);
                syscall_table[offset] = func_address;
                printk(KERN_INFO "Syscall hijacked\n");
                printk(KERN_INFO "Syscall at offset %lu : %p\n", offset, (void *)syscall_table[offset]);
                page_read_only((ulong)syscall_table);
        }
}

/* 
 * Initialization of module
 * Insert the process lookup function into the system call table at offset 400.
 */
int __init init_MyKernelModule(void)
{
  printk("Process List Lookup Module Init.\n");
  replace_syscall(SYSCALL_NI, (ulong)get_task_by_name);
  return 0;
}

/*
 * Exit of module
 * Revert changes made to the system call table.
 */
void __exit exit_MyKernelModule(void)
{
  printk("Process List Lookup Module Exit.\n");
        page_read_write((ulong)syscall_table);
        syscall_table[SYSCALL_NI] = (ulong)original_syscall;
        page_read_only((ulong)syscall_table);
        printk(KERN_INFO "Syscall at offset %d : %p\n", SYSCALL_NI, (void *)syscall_table[SYSCALL_NI]);
        printk(KERN_INFO "Custom syscall unloaded\n");
}

module_init(init_MyKernelModule);
module_exit(exit_MyKernelModule);

MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("A kernel module to list process by their names");
